#include <iostream>
#include <stdexcept>
#include <vector>
using namespace std;

class VectorCompleteTree {
public:
    VectorCompleteTree() : V(1) {} // V[0] is dummy

    int size() const { return V.size() - 1; }
    bool empty() const { return size() == 0; }
    int root() const { return 1; }
    int last() const { return size(); }

    int parent(int i) const { return i / 2; }
    int left(int i) const { return 2 * i; }
    int right(int i) const { return 2 * i + 1; }

    bool hasLeft(int i) const { return left(i) <= size(); }
    bool hasRight(int i) const { return right(i) <= size(); }
    bool isRoot(int i) const { return i == 1; }

    int& at(int i) {
        if (i <= 0 || i >= V.size()) throw out_of_range("invalid index");
        return V[i];
    }

    const int& at(int i) const {
        if (i <= 0 || i >= V.size()) throw out_of_range("invalid index");
        return V[i];
    }

    void addLast(int e) { V.push_back(e); }
    void removeLast() {
        if (empty()) throw runtime_error("empty tree");
        V.pop_back();
    }

    void swapPos(int i, int j) {
        if (i <= 0 || j <= 0 || i >= V.size() || j >= V.size())
            throw out_of_range("invalid index");
        swap(V[i], V[j]);
    }

private:
    vector<int> V; // 1-based indexing
};

class HeapPriorityQueue {
public:
    int size() const {
        return T.size();
    }

    bool empty() const {
        return T.empty();
    }

    const int& min() const {
        if (empty()) throw runtime_error("empty heap");
        return T.at(T.root());
    }

    void insert(int e) {
        T.addLast(e);             // 1. Add element at the end
        upheap(T.last());         // 2. Restore heap order
    }

    void removeMin() {
        if (empty()) {
            cout << "empty heap" << endl;
            return;
        }
        if (T.size() == 1) {
            T.removeLast();
        } else {
            T.swapPos(T.root(), T.last()); // Swap root with last
            T.removeLast();                // Remove the last element
            downheap(T.root());            // Restore heap order
        }
    }

private:
    VectorCompleteTree T;

    static bool isLess(int a, int b) { return a < b; }

    void upheap(int i) {
        while (!T.isRoot(i)) {
            int p = T.parent(i);
            if (!isLess(T.at(i), T.at(p))) break; // heap property ok
            T.swapPos(i, p);
            i = p;
        }
    }

    void downheap(int i) {
        while (T.hasLeft(i)) {
            int left = T.left(i);
            int smallChild = left;

            if (T.hasRight(i)) {
                int right = T.right(i);
                if (isLess(T.at(right), T.at(left)))
                    smallChild = right;
            }

            if (isLess(T.at(smallChild), T.at(i))) {
                T.swapPos(i, smallChild);
                i = smallChild;
            } else {
                break;
            }
        }
    }
};

int main() {
    HeapPriorityQueue pq;
    pq.insert(5);
    pq.insert(2);
    pq.insert(7);
    pq.insert(3);

    while (!pq.empty()) {
        cout << pq.min() << " ";
        pq.removeMin();
    }
    cout << "\n"; // Expected output: 2 3 5 7
    return 0;
}
